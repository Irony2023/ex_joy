# Released by rdb under the Unlicense (unlicense.org)
# Based on information from:
# https://www.kernel.org/doc/Documentation/input/joystick-api.txt
import RPi.GPIO as GPIO
import pigpio
import time
import os, struct, array
import paho.mqtt.client as mqtt
import urllib.request
from fcntl import ioctl
import threading
import subprocess



# It will be used by the modul threading. It is important for the delay for 4G.
def send_message(topic, value, zahl):
    
    client.publish(topic, value, zahl)


    
# servo1 = 17  
# servo2 = 27
# servo3 = 22

broker = '192.168.7.22' # This is also the ip address of the Husky
print("Connecting control to broker (excavator) on 192.168.7.22 (ip address of excavator)")




delay_flag = False # 5G is always enable

# pwm = pigpio.pi()
# pwm.set_mode(servo1, pigpio.OUTPUT)
# pwm.set_PWM_frequency( servo1, 50 )
# pwm.set_PWM_frequency( servo2, 50 )
# pwm.set_PWM_frequency( servo3, 50 )
client = mqtt.Client()
# client.on_message=on_message
client.connect(broker, 1883, 60)
client.loop_start()
print("Connected.")
# Iterate over the joystick devices.
print('Available devices:')

for fn in os.listdir('/dev/input'):
    if fn.startswith('js'):
        print('  /dev/input/%s' % (fn))

# We'll store the states here.
axis_states = {}
button_states = {}

# These constants were borrowed from linux/input.h
axis_names = {
    0x00 : 'x',
    0x01 : 'y',
    0x02 : 'z',
    0x03 : 'rx',
    0x04 : 'ry',
    0x05 : 'rz',
    0x06 : 'throttle',
    0x07 : 'rudder',
    0x08 : 'wheel',
    0x09 : 'gas',
    0x0a : 'brake',
    0x10 : 'hat0x',
    0x11 : 'hat0y',
    0x12 : 'hat1x',
    0x13 : 'hat1y',
    0x14 : 'hat2x',
    0x15 : 'hat2y',
    0x16 : 'hat3x',
    0x17 : 'hat3y',
    0x18 : 'pressure',
    0x19 : 'distance',
    0x1a : 'tilt_x',
    0x1b : 'tilt_y',
    0x1c : 'tool_width',
    0x20 : 'volume',
    0x28 : 'misc',
}

button_names = {
    0x120 : 'trigger',
    0x121 : 'thumb',
    0x122 : 'thumb2',
    0x123 : 'top',
    0x124 : 'top2',
    0x125 : 'pinkie',
    0x126 : 'base',
    0x127 : 'base2',
    0x128 : 'base3',
    0x129 : 'base4',
    0x12a : 'base5',
    0x12b : 'base6',
    0x12f : 'dead',
    0x130 : 'a',
    0x131 : 'b',
    0x132 : 'c',
    0x133 : 'x',
    0x134 : 'y',
    0x135 : 'z',
    0x136 : 'tl',
    0x137 : 'tr',
    0x138 : 'tl2',
    0x139 : 'tr2',
    0x13a : 'select',
    0x13b : 'start',
    0x13c : 'mode',
    0x13d : 'thumbl',
    0x13e : 'thumbr',

    0x220 : 'dpad_up',
    0x221 : 'dpad_down',
    0x222 : 'dpad_left',
    0x223 : 'dpad_right',

    # XBox 360 controller uses these codes.
    0x2c0 : 'dpad_left',
    0x2c1 : 'dpad_right',
    0x2c2 : 'dpad_up',
    0x2c3 : 'dpad_down',
}

axis_map = []
button_map = []

# Open the joystick device.
fn = '/dev/input/js0'
print('Opening %s...' % fn)
jsdev = open(fn, 'rb')

# Get the device name.
#buf = bytearray(63)
buf = array.array('B', [0] * 64)
ioctl(jsdev, 0x80006a13 + (0x10000 * len(buf)), buf) # JSIOCGNAME(len)
js_name = buf.tobytes().rstrip(b'\x00').decode('utf-8')
print('Device name: %s' % js_name)

# Get number of axes and buttons.
buf = array.array('B', [0])
ioctl(jsdev, 0x80016a11, buf) # JSIOCGAXES
num_axes = buf[0]

buf = array.array('B', [0])
ioctl(jsdev, 0x80016a12, buf) # JSIOCGBUTTONS
num_buttons = buf[0]

# Get the axis map.
buf = array.array('B', [0] * 0x40)
ioctl(jsdev, 0x80406a32, buf) # JSIOCGAXMAP

for axis in buf[:num_axes]:
    axis_name = axis_names.get(axis, 'unknown(0x%02x)' % axis)
    axis_map.append(axis_name)
    axis_states[axis_name] = 0.0

# Get the button map.
buf = array.array('H', [0] * 200)
ioctl(jsdev, 0x80406a34, buf) # JSIOCGBTNMAP

for btn in buf[:num_buttons]:
    btn_name = button_names.get(btn, 'unknown(0x%03x)' % btn)
    button_map.append(btn_name)
    button_states[btn_name] = 0

print('%d axes found: %s' % (num_axes, ', '.join(axis_map)))
print('%d buttons found: %s' % (num_buttons, ', '.join(button_map)))
# Main event loop



delay_for_g = 1.00 #1 #0.100 # It has to be a float value. With this value 4G will be simulated -->changed the0.5 to 0.100
camera_process = None  # Initialize the camera process variable


while True:
    
    axis_percentage = 0
    servo_pulsewidth = 0
    evbuf = jsdev.read(8)
    
    # Check if delay for 4G is activated
    if delay_flag == False:
        
        if evbuf:
            time1, value, type, number = struct.unpack('IhBB', evbuf) # Get the value of the varible 'value'

            if type & 0x80:
                 # do nothing
                 pass
                 #print("(initial)", end="")
            
            # Check the state of the buttons and identify, which button was used.
            # Every button is assigned a number
            if type & 0x01:
                button = button_map[number]
                
                # Get the value of the button. If it was pressed is 1 otherwise 0
                if button:
                    button_states[button] = value
    #                 if value:
    #                     print(number)
    #                     print("%s pressed" % (button))
    #                 else:
    #                     print(number)
    #                     print("%s released" % (button))
                
                
                # Button 'B' --> 4G
                if number == 1:
                    
                    if value == 1: # Button pressed
                        
                        delay_flag = True # 4G
                    
                        client.publish('gamepad/b', value, 0) # 4G --> Nachricht senden, damit LED rot beleuchtet
                        
                    if value:
                        print("b pressed")
                    else:
                        print("b released")
                
                
                # Button 'X' --> 5G
                if number == 2:
                    
                    if value == 1: # Button pressed
                        
                        delay_flag = False # 5G
                    
                        client.publish('gamepad/x', value, 0) # 5G --> Nachricht senden, damit LED gruen beleuchtet
                    
                    if value:
                        print("x pressed")
                    else:
                        print("x released")
                if number == 3:
                    if value:
                        print("y pressed")
                    else:
                        print("y released")
                
                
                # Button 'A' --> Streaming the videos
                if number == 0:
                    
                    if value == 1: # Button pres
                        
                         client.publish('gamepad/a', value, 0)
                         print ("button a pressed")
                        
                        #os.system("sudo reboot") # reboot control

    #                else:
    #                    print("a released")
    
                
                # Button 'LB' --> left/rigth drive
                if number == 4:
    #                print("LB Input:")
                    
                        
                    client.publish('gamepad/LB', value, 0)
    #            if number == 5:
    #                if value:
    #                    print("RB pressed")
    #                else:
    #                    print("RB released")
    #            if number == 6:
    #                if value:
                            
    #                    client.publish('gamepad/BACK', value, 0)
    #                    print("BACK pressed")
    #                else:
    #                     print("BACK released")
    #            if number == 7:
    #                if value:
    #                    print("START pressed")
    #                else:
    #                    print("START released")
    #            if number == 10:
    #                if value:
    #                    print("Rechter Stick pressed")
    #                else:
    #                    print("Rechter Stick released")
    #            if number == 9:
    #                if value:
    #                    print("Linker Stick pressed")
    #                else:
    #                    print("Linker Stick released")
                        
            # Check the state of axes and identify, which axis was used.
            # Every axis is assigned a number            
            if type & 0x02:
                axis = axis_map[number]
                
                # Get the value of the axis and save it in fvalue. Values of fvalue lies between -1,0 and 1,0.
                if axis:
                    fvalue = value / 32767.0 # Value of the axes between -32767 and 32767.
                    axis_states[axis] = fvalue
                    print("%s: %.3f" % (axis, fvalue))
                    
                    # Left joystick: axis-y --> Boom
                    if number == 1:
                        #fvalue=fvalue*(-1)
                        print("Linker Stick Y: %.3f" % (fvalue))

                        
                        client.publish('gamepad/linkerstick_y', fvalue, 0)
    #                     servo_pulsewidth = fvalue*500+1500
    #                     pwm.set_servo_pulsewidth( servo2, servo_pulsewidth)
                    
                    
                    # Axis 'LT' --> Bucket
                    if number == 2:
                        print("LT: %.3f" % (fvalue))
                        axis_percentage = ((fvalue+1)/2) # With this formel we gets values between 0,0 and 1,0.
                        
                        
                        client.publish('gamepad/LT', axis_percentage, 0)
    #                     servo_pulsewidth = axis_percentage*(-1000)+1500
    #                     pwm.set_servo_pulsewidth( servo1, servo_pulsewidth)
                    if number == 3:
                        print("Rechter Stick X: %.3f" % (fvalue))
                    
                    
                    # Right joystick: axis-y --> Arm
                    if number == 4:
                        print("Rechter Stick Y: %.3f" % (fvalue))
                        
                        client.publish('gamepad/rechterstick_y', fvalue, 0)
    #                     servo_pulsewidth = fvalue*500+1400
    #                     pwm.set_servo_pulsewidth( servo3, servo_pulsewidth)
                    
                    
                    # Axis 'RT' --> Bucket
                    if number == 5:
    #                    print("RT: %.3f" % (fvalue))
                        axis_percentage = ((fvalue+1)/2)
                         
                        client.publish('gamepad/RT', axis_percentage, 0)
    #                     servo_pulsewidth = axis_percentage*500+1500
    #                     pwm.set_servo_pulsewidth( servo1, servo_pulsewidth)
                    
                    
                    # Left joystick: x-axis --> swing
                    if number == 0:
                        fvalue=fvalue*(-1)
                        
                        client.publish('gamepad/linkerstick_x', fvalue, 0)
    #                    print("Linker Stick X: %.3f" % (fvalue))
                        
                    if number == 6:
                        print("D_Pad X: %.3f" % (fvalue))
                    if number == 7:
                        print("D_Pad Y: %.3f" % (fvalue))
    
    
    # Almost same code as above just only threading modul for 4G delay added. 
    # 4G was activated.
    elif delay_flag == True:
        
        if evbuf:
            time1, value, type, number = struct.unpack('IhBB', evbuf)

            if type & 0x80:
                pass
                #print("(initial)", end="")

            if type & 0x01:
                button = button_map[number]
                
                # Get the value of the button. If it was pressed is 1 otherwise 0
                if button:
                    button_states[button] = value
    #                 if value:
    #                     print(number)
    #                     print("%s pressed" % (button))
    #                 else:
    #                     print(number)
    #                     print("%s released" % (button))
                
                
                # Button 'B' --> 4G
                if number == 1:
                    
                    if value == 1: # Button pressed
                        
                        delay_flag = True # 4G
                    
                        client.publish('gamepad/b', value, 0) # 4G --> Nachricht senden, damit LED rot beleuchtet
                        
    #                if value:
    #                    print("b pressed")
    #                else:
    #                    print("b released")
                
                
                # Button 'X' --> 5G
                if number == 2:
                    
                    if value == 1: # Button pressed
                        
                        delay_flag = False # 5G
                    
                        client.publish('gamepad/x', value, 0) # 5G --> Nachricht senden, damit LED gruen beleuchtet
                    
    #                if value:
    #                    print("x pressed")
    #                else:
    #                    print("x released")
    #            if number == 3:
    #                if value:
    #                    print("y pressed")
    #                else:
    #                    print("y released")
                
                
                # Button 'A' --> reboot control
                if number == 0:
                    
                    if value == 1: # Button pressed
                        
                        client.publish('gamepad/a', value, 0)
                        
                        #os.system("sudo reboot") # reboot control
    #                else:
    #                    print("a released")
                
                
                # Button 'LB' --> left/rigth drive
                if number == 4:
    #                print("LB Input:")
                    
                    threading.Timer(delay_for_g, send_message, args=['gamepad/LB', value, 0]).start() # It allows to simulate the delay for 4G.
                    
                    #client.publish('gamepad/LB', value, 0)
    #            if number == 5:
    #                if value:
    #                    print("RB pressed")
    #                else:
    #                    print("RB released")
                
    #            if number == 6:
    #                if value:
                        
    #                    threading.Timer(delay_for_g, send_message, args=['gamepad/BACK', value, 0]).start()
                        
                        #client.publish('gamepad/BACK', value, 0)
    #                    print("BACK pressed")
    #                else:
    #                     print("BACK released")
    #            if number == 7:
    #                if value:
    #                    print("START pressed")
    #                else:
    #                    print("START released")
    #            if number == 10:
    #                if value:
    #                    print("Rechter Stick pressed")
    #                else:
    #                    print("Rechter Stick released")
    #            if number == 9:
    #                if value:
    #                    print("Linker Stick pressed")
    #                else:
    #                    print("Linker Stick released")
                        
                        
            if type & 0x02:
                axis = axis_map[number]
                if axis:
                    fvalue = value / 32767.0
                    axis_states[axis] = fvalue
    #                 print("%s: %.3f" % (axis, fvalue))
                    
                    
                    # Left joystick: axis-y --> Boom
                    if number == 1:
                        #fvalue=fvalue*(-1)
    #                    print("Linker Stick Y: %.3f" % (fvalue))
                        
                        threading.Timer(delay_for_g, send_message, args=['gamepad/linkerstick_y', fvalue, 0]).start() # It allows to simulate the delay for 4G
                        
                        #client.publish('gamepad/linkerstick_y', fvalue, 0)
    #                     servo_pulsewidth = fvalue*500+1500
    #                     pwm.set_servo_pulsewidth( servo2, servo_pulsewidth)
                    
                    
                    # Axis 'LT' --> Bucket
                    if number == 2:
    #                    print("LT: %.3f" % (fvalue))
                        axis_percentage = ((fvalue+1)/2)
                        
                        threading.Timer(delay_for_g, send_message, args=['gamepad/LT', axis_percentage, 0]).start() # It allows to simulate the delay for 4G
                        
                        #client.publish('gamepad/LT', axis_percentage, 0)
    #                     servo_pulsewidth = axis_percentage*(-1000)+1500
    #                     pwm.set_servo_pulsewidth( servo1, servo_pulsewidth)
    #                if number == 3:
    #                    print("Rechter Stick X: %.3f" % (fvalue))
                    
                    
                    # Right joystick: axis-y --> Arm
                    if number == 4:
    #                    print("Rechter Stick Y: %.3f" % (fvalue))
                        
                        threading.Timer(delay_for_g, send_message, args=['gamepad/rechterstick_y', fvalue, 0]).start() # It allows to simulate the delay for 4G
                        
                        #client.publish('gamepad/rechterstick_y', fvalue, 0)
                        
    #                     servo_pulsewidth = fvalue*500+1400
    #                     pwm.set_servo_pulsewidth( servo3, servo_pulsewidth)
                    
                    
                    # Axis 'RT' --> Bucket
                    if number == 5:
    #                    print("RT: %.3f" % (fvalue))
                        axis_percentage = ((fvalue+1)/2)
                        
                        threading.Timer(delay_for_g, send_message, args=['gamepad/RT', axis_percentage, 0]).start() # It allows to simulate the delay for 4G
                        
                        #client.publish('gamepad/RT', axis_percentage, 0)
    #                     servo_pulsewidth = axis_percentage*500+1500
    #                     pwm.set_servo_pulsewidth( servo1, servo_pulsewidth)
                    
                    
                    # Left joystick: x-axis --> swing
                    if number == 0:
                        fvalue=fvalue*(-1)
                        
                        threading.Timer(delay_for_g, send_message, args=['gamepad/linkerstick_x', fvalue, 0]).start() # It allows to simulate the delay for 4G
                        
                        #client.publish('gamepad/linkerstick_x', fvalue, 0)
    #                    print("Linker Stick X: %.3f" % (fvalue))
                        
    #                if number == 6:
    #                    print("D_Pad X: %.3f" % (fvalue))
    #                if number == 7:
    #                    print("D_Pad Y: %.3f" % (fvalue))
        




        
print("Now trying to send data...")
client.loop_stop()
client.disconnect()





